"""
    Apache NiFi REST API

    REST API definition for Apache NiFi web services

    OpenAPI spec version: 2.5.0
    Contact: dev@nifi.apache.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import sys
import os
import re

from ..configuration import Configuration
from ..api_client import ApiClient


class ProcessGroupsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def copy(self, body, id, **kwargs):
        """
        Generates a copy response for the given copy request
        This method makes a synchronous HTTP request.
        :param CopyRequestEntity body: The request including the components to be copied from the specified Process Group. (required)
        :param str id: The process group id. (required)
        :return: CopyResponseEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.copy_with_http_info(body, id, **kwargs)
        else:
            (data) = self.copy_with_http_info(body, id, **kwargs)
            return data

    def copy_with_http_info(self, body, id, **kwargs):
        """
        Generates a copy response for the given copy request
        This method makes a synchronous HTTP request.
        :param CopyRequestEntity body: The request including the components to be copied from the specified Process Group. (required)
        :param str id: The process group id. (required)
        :return: CopyResponseEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `copy`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/copy', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CopyResponseEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def copy_snippet(self, body, id, **kwargs):
        """
        Copies a snippet and discards it.
        This method makes a synchronous HTTP request.
        :param CopySnippetRequestEntity body: The copy snippet request. (required)
        :param str id: The process group id. (required)
        :return: FlowEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.copy_snippet_with_http_info(body, id, **kwargs)
        else:
            (data) = self.copy_snippet_with_http_info(body, id, **kwargs)
            return data

    def copy_snippet_with_http_info(self, body, id, **kwargs):
        """
        Copies a snippet and discards it.
        This method makes a synchronous HTTP request.
        :param CopySnippetRequestEntity body: The copy snippet request. (required)
        :param str id: The process group id. (required)
        :return: FlowEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_snippet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_snippet`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `copy_snippet`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/snippet-instance', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FlowEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_connection(self, body, id, **kwargs):
        """
        Creates a connection
        This method makes a synchronous HTTP request.
        :param ConnectionEntity body: The connection configuration details. (required)
        :param str id: The process group id. (required)
        :return: ConnectionEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_connection_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_connection_with_http_info(body, id, **kwargs)
            return data

    def create_connection_with_http_info(self, body, id, **kwargs):
        """
        Creates a connection
        This method makes a synchronous HTTP request.
        :param ConnectionEntity body: The connection configuration details. (required)
        :param str id: The process group id. (required)
        :return: ConnectionEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_connection`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_connection`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/connections', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConnectionEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_controller_service1(self, body, id, **kwargs):
        """
        Creates a new controller service
        This method makes a synchronous HTTP request.
        :param ControllerServiceEntity body: The controller service configuration details. (required)
        :param str id: The process group id. (required)
        :return: ControllerServiceEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_controller_service1_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_controller_service1_with_http_info(body, id, **kwargs)
            return data

    def create_controller_service1_with_http_info(self, body, id, **kwargs):
        """
        Creates a new controller service
        This method makes a synchronous HTTP request.
        :param ControllerServiceEntity body: The controller service configuration details. (required)
        :param str id: The process group id. (required)
        :return: ControllerServiceEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_controller_service1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_controller_service1`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_controller_service1`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/controller-services', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ControllerServiceEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_empty_all_connections_request(self, id, **kwargs):
        """
        Creates a request to drop all flowfiles of all connection queues in this process group.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: DropRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_empty_all_connections_request_with_http_info(id, **kwargs)
        else:
            (data) = self.create_empty_all_connections_request_with_http_info(id, **kwargs)
            return data

    def create_empty_all_connections_request_with_http_info(self, id, **kwargs):
        """
        Creates a request to drop all flowfiles of all connection queues in this process group.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: DropRequestEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_empty_all_connections_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_empty_all_connections_request`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/empty-all-connections-requests', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DropRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_funnel(self, body, id, **kwargs):
        """
        Creates a funnel
        This method makes a synchronous HTTP request.
        :param FunnelEntity body: The funnel configuration details. (required)
        :param str id: The process group id. (required)
        :return: FunnelEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_funnel_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_funnel_with_http_info(body, id, **kwargs)
            return data

    def create_funnel_with_http_info(self, body, id, **kwargs):
        """
        Creates a funnel
        This method makes a synchronous HTTP request.
        :param FunnelEntity body: The funnel configuration details. (required)
        :param str id: The process group id. (required)
        :return: FunnelEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_funnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_funnel`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_funnel`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/funnels', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FunnelEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_input_port(self, body, id, **kwargs):
        """
        Creates an input port
        This method makes a synchronous HTTP request.
        :param PortEntity body: The input port configuration details. (required)
        :param str id: The process group id. (required)
        :return: PortEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_input_port_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_input_port_with_http_info(body, id, **kwargs)
            return data

    def create_input_port_with_http_info(self, body, id, **kwargs):
        """
        Creates an input port
        This method makes a synchronous HTTP request.
        :param PortEntity body: The input port configuration details. (required)
        :param str id: The process group id. (required)
        :return: PortEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_input_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_input_port`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_input_port`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/input-ports', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PortEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_label(self, body, id, **kwargs):
        """
        Creates a label
        This method makes a synchronous HTTP request.
        :param LabelEntity body: The label configuration details. (required)
        :param str id: The process group id. (required)
        :return: LabelEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_label_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_label_with_http_info(body, id, **kwargs)
            return data

    def create_label_with_http_info(self, body, id, **kwargs):
        """
        Creates a label
        This method makes a synchronous HTTP request.
        :param LabelEntity body: The label configuration details. (required)
        :param str id: The process group id. (required)
        :return: LabelEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_label`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_label`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/labels', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LabelEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_output_port(self, body, id, **kwargs):
        """
        Creates an output port
        This method makes a synchronous HTTP request.
        :param PortEntity body: The output port configuration. (required)
        :param str id: The process group id. (required)
        :return: PortEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_output_port_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_output_port_with_http_info(body, id, **kwargs)
            return data

    def create_output_port_with_http_info(self, body, id, **kwargs):
        """
        Creates an output port
        This method makes a synchronous HTTP request.
        :param PortEntity body: The output port configuration. (required)
        :param str id: The process group id. (required)
        :return: PortEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_output_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_output_port`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_output_port`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/output-ports', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PortEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_process_group(self, body, id, **kwargs):
        """
        Creates a process group
        This method makes a synchronous HTTP request.
        :param ProcessGroupEntity body: The process group configuration details. (required)
        :param str id: The process group id. (required)
        :param str parameter_context_handling_strategy: Handling Strategy controls whether to keep or replace Parameter Contexts
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_process_group_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_process_group_with_http_info(body, id, **kwargs)
            return data

    def create_process_group_with_http_info(self, body, id, **kwargs):
        """
        Creates a process group
        This method makes a synchronous HTTP request.
        :param ProcessGroupEntity body: The process group configuration details. (required)
        :param str id: The process group id. (required)
        :param str parameter_context_handling_strategy: Handling Strategy controls whether to keep or replace Parameter Contexts
        :return: ProcessGroupEntity
        """

        all_params = ['body', 'id', 'parameter_context_handling_strategy']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_process_group`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_process_group`")

 
 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'parameter_context_handling_strategy' in params:
            query_params.append(('parameterContextHandlingStrategy', params['parameter_context_handling_strategy']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/process-groups', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_processor(self, body, id, **kwargs):
        """
        Creates a new processor
        This method makes a synchronous HTTP request.
        :param ProcessorEntity body: The processor configuration details. (required)
        :param str id: The process group id. (required)
        :return: ProcessorEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_processor_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_processor_with_http_info(body, id, **kwargs)
            return data

    def create_processor_with_http_info(self, body, id, **kwargs):
        """
        Creates a new processor
        This method makes a synchronous HTTP request.
        :param ProcessorEntity body: The processor configuration details. (required)
        :param str id: The process group id. (required)
        :return: ProcessorEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_processor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_processor`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_processor`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/processors', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessorEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_remote_process_group(self, body, id, **kwargs):
        """
        Creates a new process group
        This method makes a synchronous HTTP request.
        :param RemoteProcessGroupEntity body: The remote process group configuration details. (required)
        :param str id: The process group id. (required)
        :return: RemoteProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_remote_process_group_with_http_info(body, id, **kwargs)
        else:
            (data) = self.create_remote_process_group_with_http_info(body, id, **kwargs)
            return data

    def create_remote_process_group_with_http_info(self, body, id, **kwargs):
        """
        Creates a new process group
        This method makes a synchronous HTTP request.
        :param RemoteProcessGroupEntity body: The remote process group configuration details. (required)
        :param str id: The process group id. (required)
        :return: RemoteProcessGroupEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_remote_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_remote_process_group`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_remote_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/remote-process-groups', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RemoteProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_replace_process_group_request(self, id, **kwargs):
        """
        Deletes the Replace Request with the given ID
        Deletes the Replace Request with the given ID. After a request is created via a POST to /process-groups/{id}/replace-requests, it is expected that the client will properly clean up the request by DELETE'ing it, once the Replace process has completed. If the request is deleted before the request completes, then the Replace request will finish the step that it is currently performing and then will cancel any subsequent steps. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param str id: The ID of the Update Request (required)
        :param bool disconnected_node_acknowledged: Acknowledges that this node is disconnected to allow for mutable requests to proceed.
        :return: ProcessGroupReplaceRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_replace_process_group_request_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_replace_process_group_request_with_http_info(id, **kwargs)
            return data

    def delete_replace_process_group_request_with_http_info(self, id, **kwargs):
        """
        Deletes the Replace Request with the given ID
        Deletes the Replace Request with the given ID. After a request is created via a POST to /process-groups/{id}/replace-requests, it is expected that the client will properly clean up the request by DELETE'ing it, once the Replace process has completed. If the request is deleted before the request completes, then the Replace request will finish the step that it is currently performing and then will cancel any subsequent steps. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param str id: The ID of the Update Request (required)
        :param bool disconnected_node_acknowledged: Acknowledges that this node is disconnected to allow for mutable requests to proceed.
        :return: ProcessGroupReplaceRequestEntity
        """

        all_params = ['id', 'disconnected_node_acknowledged']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_replace_process_group_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_replace_process_group_request`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'disconnected_node_acknowledged' in params:
            query_params.append(('disconnectedNodeAcknowledged', params['disconnected_node_acknowledged']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/replace-requests/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupReplaceRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def export_process_group(self, id, **kwargs):
        """
        Gets a process group for download
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param bool include_referenced_services: If referenced services from outside the target group should be included
        :return: str
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.export_process_group_with_http_info(id, **kwargs)
        else:
            (data) = self.export_process_group_with_http_info(id, **kwargs)
            return data

    def export_process_group_with_http_info(self, id, **kwargs):
        """
        Gets a process group for download
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param bool include_referenced_services: If referenced services from outside the target group should be included
        :return: str
        """

        all_params = ['id', 'include_referenced_services']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `export_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'include_referenced_services' in params:
            query_params.append(('includeReferencedServices', params['include_referenced_services']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/download', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_connections(self, id, **kwargs):
        """
        Gets all connections
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ConnectionsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_connections_with_http_info(id, **kwargs)
        else:
            (data) = self.get_connections_with_http_info(id, **kwargs)
            return data

    def get_connections_with_http_info(self, id, **kwargs):
        """
        Gets all connections
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ConnectionsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connections" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_connections`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/connections', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConnectionsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_drop_all_flowfiles_request(self, id, drop_request_id, **kwargs):
        """
        Gets the current status of a drop all flowfiles request.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str drop_request_id: The drop request id. (required)
        :return: DropRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_drop_all_flowfiles_request_with_http_info(id, drop_request_id, **kwargs)
        else:
            (data) = self.get_drop_all_flowfiles_request_with_http_info(id, drop_request_id, **kwargs)
            return data

    def get_drop_all_flowfiles_request_with_http_info(self, id, drop_request_id, **kwargs):
        """
        Gets the current status of a drop all flowfiles request.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str drop_request_id: The drop request id. (required)
        :return: DropRequestEntity
        """

        all_params = ['id', 'drop_request_id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_drop_all_flowfiles_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_drop_all_flowfiles_request`")
        # verify the required parameter 'drop_request_id' is set
        if ('drop_request_id' not in params) or (params['drop_request_id'] is None):
            raise ValueError("Missing the required parameter `drop_request_id` when calling `get_drop_all_flowfiles_request`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'drop_request_id' in params:
            path_params['drop-request-id'] = params['drop_request_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/empty-all-connections-requests/{drop-request-id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DropRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_funnels(self, id, **kwargs):
        """
        Gets all funnels
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: FunnelsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_funnels_with_http_info(id, **kwargs)
        else:
            (data) = self.get_funnels_with_http_info(id, **kwargs)
            return data

    def get_funnels_with_http_info(self, id, **kwargs):
        """
        Gets all funnels
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: FunnelsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_funnels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_funnels`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/funnels', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FunnelsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_input_ports(self, id, **kwargs):
        """
        Gets all input ports
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: InputPortsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_input_ports_with_http_info(id, **kwargs)
        else:
            (data) = self.get_input_ports_with_http_info(id, **kwargs)
            return data

    def get_input_ports_with_http_info(self, id, **kwargs):
        """
        Gets all input ports
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: InputPortsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_input_ports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_input_ports`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/input-ports', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InputPortsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_labels(self, id, **kwargs):
        """
        Gets all labels
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: LabelsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_labels_with_http_info(id, **kwargs)
        else:
            (data) = self.get_labels_with_http_info(id, **kwargs)
            return data

    def get_labels_with_http_info(self, id, **kwargs):
        """
        Gets all labels
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: LabelsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_labels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_labels`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/labels', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LabelsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_local_modifications(self, id, **kwargs):
        """
        Gets a list of local modifications to the Process Group since it was last synchronized with the Flow Registry
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: FlowComparisonEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_local_modifications_with_http_info(id, **kwargs)
        else:
            (data) = self.get_local_modifications_with_http_info(id, **kwargs)
            return data

    def get_local_modifications_with_http_info(self, id, **kwargs):
        """
        Gets a list of local modifications to the Process Group since it was last synchronized with the Flow Registry
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: FlowComparisonEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_local_modifications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_local_modifications`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/local-modifications', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FlowComparisonEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_output_ports(self, id, **kwargs):
        """
        Gets all output ports
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: OutputPortsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_output_ports_with_http_info(id, **kwargs)
        else:
            (data) = self.get_output_ports_with_http_info(id, **kwargs)
            return data

    def get_output_ports_with_http_info(self, id, **kwargs):
        """
        Gets all output ports
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: OutputPortsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_output_ports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_output_ports`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/output-ports', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OutputPortsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_process_group(self, id, **kwargs):
        """
        Gets a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_process_group_with_http_info(id, **kwargs)
        else:
            (data) = self.get_process_group_with_http_info(id, **kwargs)
            return data

    def get_process_group_with_http_info(self, id, **kwargs):
        """
        Gets a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ProcessGroupEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_process_group`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_process_groups(self, id, **kwargs):
        """
        Gets all process groups
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ProcessGroupsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_process_groups_with_http_info(id, **kwargs)
        else:
            (data) = self.get_process_groups_with_http_info(id, **kwargs)
            return data

    def get_process_groups_with_http_info(self, id, **kwargs):
        """
        Gets all process groups
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: ProcessGroupsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_process_groups`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/process-groups', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_processors(self, id, **kwargs):
        """
        Gets all processors
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param bool include_descendant_groups: Whether or not to include processors from descendant process groups
        :return: ProcessorsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_processors_with_http_info(id, **kwargs)
        else:
            (data) = self.get_processors_with_http_info(id, **kwargs)
            return data

    def get_processors_with_http_info(self, id, **kwargs):
        """
        Gets all processors
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param bool include_descendant_groups: Whether or not to include processors from descendant process groups
        :return: ProcessorsEntity
        """

        all_params = ['id', 'include_descendant_groups']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_processors`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'include_descendant_groups' in params:
            query_params.append(('includeDescendantGroups', params['include_descendant_groups']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/processors', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessorsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_remote_process_groups(self, id, **kwargs):
        """
        Gets all remote process groups
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: RemoteProcessGroupsEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_remote_process_groups_with_http_info(id, **kwargs)
        else:
            (data) = self.get_remote_process_groups_with_http_info(id, **kwargs)
            return data

    def get_remote_process_groups_with_http_info(self, id, **kwargs):
        """
        Gets all remote process groups
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :return: RemoteProcessGroupsEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_process_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_remote_process_groups`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/remote-process-groups', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RemoteProcessGroupsEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_replace_process_group_request(self, id, **kwargs):
        """
        Returns the Replace Request with the given ID
        Returns the Replace Request with the given ID. Once a Replace Request has been created by performing a POST to /process-groups/{id}/replace-requests, that request can subsequently be retrieved via this endpoint, and the request that is fetched will contain the updated state, such as percent complete, the current state of the request, and any failures. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param str id: The ID of the Replace Request (required)
        :return: ProcessGroupReplaceRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_replace_process_group_request_with_http_info(id, **kwargs)
        else:
            (data) = self.get_replace_process_group_request_with_http_info(id, **kwargs)
            return data

    def get_replace_process_group_request_with_http_info(self, id, **kwargs):
        """
        Returns the Replace Request with the given ID
        Returns the Replace Request with the given ID. Once a Replace Request has been created by performing a POST to /process-groups/{id}/replace-requests, that request can subsequently be retrieved via this endpoint, and the request that is fetched will contain the updated state, such as percent complete, the current state of the request, and any failures. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param str id: The ID of the Replace Request (required)
        :return: ProcessGroupReplaceRequestEntity
        """

        all_params = ['id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_replace_process_group_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_replace_process_group_request`")

 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/replace-requests/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupReplaceRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def import_process_group(self, id, **kwargs):
        """
        Imports a specified process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param ProcessGroupUploadEntity body:
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.import_process_group_with_http_info(id, **kwargs)
        else:
            (data) = self.import_process_group_with_http_info(id, **kwargs)
            return data

    def import_process_group_with_http_info(self, id, **kwargs):
        """
        Imports a specified process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param ProcessGroupUploadEntity body:
        :return: ProcessGroupEntity
        """

        all_params = ['id', 'body']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `import_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/process-groups/import', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def initiate_replace_process_group(self, body, id, **kwargs):
        """
        Initiate the Replace Request of a Process Group with the given ID
        This will initiate the action of replacing a process group with the given process group. This can be a lengthy process, as it will stop any Processors and disable any Controller Services necessary to perform the action and then restart them. As a result, the endpoint will immediately return a ProcessGroupReplaceRequestEntity, and the process of replacing the flow will occur asynchronously in the background. The client may then periodically poll the status of the request by issuing a GET request to /process-groups/replace-requests/{requestId}. Once the request is completed, the client is expected to issue a DELETE request to /process-groups/replace-requests/{requestId}. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param ProcessGroupImportEntity body: The process group replace request entity (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupReplaceRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.initiate_replace_process_group_with_http_info(body, id, **kwargs)
        else:
            (data) = self.initiate_replace_process_group_with_http_info(body, id, **kwargs)
            return data

    def initiate_replace_process_group_with_http_info(self, body, id, **kwargs):
        """
        Initiate the Replace Request of a Process Group with the given ID
        This will initiate the action of replacing a process group with the given process group. This can be a lengthy process, as it will stop any Processors and disable any Controller Services necessary to perform the action and then restart them. As a result, the endpoint will immediately return a ProcessGroupReplaceRequestEntity, and the process of replacing the flow will occur asynchronously in the background. The client may then periodically poll the status of the request by issuing a GET request to /process-groups/replace-requests/{requestId}. Once the request is completed, the client is expected to issue a DELETE request to /process-groups/replace-requests/{requestId}. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param ProcessGroupImportEntity body: The process group replace request entity (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupReplaceRequestEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method initiate_replace_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `initiate_replace_process_group`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `initiate_replace_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/replace-requests', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupReplaceRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def paste(self, body, id, **kwargs):
        """
        Pastes into the specified process group
        This method makes a synchronous HTTP request.
        :param PasteRequestEntity body: The request including the components to be pasted into the specified Process Group. (required)
        :param str id: The process group id. (required)
        :return: PasteResponseEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.paste_with_http_info(body, id, **kwargs)
        else:
            (data) = self.paste_with_http_info(body, id, **kwargs)
            return data

    def paste_with_http_info(self, body, id, **kwargs):
        """
        Pastes into the specified process group
        This method makes a synchronous HTTP request.
        :param PasteRequestEntity body: The request including the components to be pasted into the specified Process Group. (required)
        :param str id: The process group id. (required)
        :return: PasteResponseEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method paste" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `paste`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `paste`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/paste', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PasteResponseEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_drop_request1(self, id, drop_request_id, **kwargs):
        """
        Cancels and/or removes a request to drop all flowfiles.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str drop_request_id: The drop request id. (required)
        :return: DropRequestEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_drop_request1_with_http_info(id, drop_request_id, **kwargs)
        else:
            (data) = self.remove_drop_request1_with_http_info(id, drop_request_id, **kwargs)
            return data

    def remove_drop_request1_with_http_info(self, id, drop_request_id, **kwargs):
        """
        Cancels and/or removes a request to drop all flowfiles.
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str drop_request_id: The drop request id. (required)
        :return: DropRequestEntity
        """

        all_params = ['id', 'drop_request_id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_drop_request1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_drop_request1`")
        # verify the required parameter 'drop_request_id' is set
        if ('drop_request_id' not in params) or (params['drop_request_id'] is None):
            raise ValueError("Missing the required parameter `drop_request_id` when calling `remove_drop_request1`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'drop_request_id' in params:
            path_params['drop-request-id'] = params['drop_request_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/empty-all-connections-requests/{drop-request-id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DropRequestEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_process_group(self, id, **kwargs):
        """
        Deletes a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param LongParameter version: The revision is used to verify the client is working with the latest version of the flow.
        :param ClientIdParameter client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :param bool disconnected_node_acknowledged: Acknowledges that this node is disconnected to allow for mutable requests to proceed.
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_process_group_with_http_info(id, **kwargs)
        else:
            (data) = self.remove_process_group_with_http_info(id, **kwargs)
            return data

    def remove_process_group_with_http_info(self, id, **kwargs):
        """
        Deletes a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param LongParameter version: The revision is used to verify the client is working with the latest version of the flow.
        :param ClientIdParameter client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :param bool disconnected_node_acknowledged: Acknowledges that this node is disconnected to allow for mutable requests to proceed.
        :return: ProcessGroupEntity
        """

        all_params = ['id', 'version', 'client_id', 'disconnected_node_acknowledged']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_process_group`")

 
 
 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))
        if 'disconnected_node_acknowledged' in params:
            query_params.append(('disconnectedNodeAcknowledged', params['disconnected_node_acknowledged']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def replace_process_group(self, body, id, **kwargs):
        """
        Replace Process Group contents with the given ID with the specified Process Group contents
        This endpoint is used for replication within a cluster, when replacing a flow with a new flow. It expects that the flow beingreplaced is not under version control and that the given snapshot will not modify any Processor that is currently running or any Controller Service that is enabled. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param ProcessGroupImportEntity body: The process group replace request entity. (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupImportEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_process_group_with_http_info(body, id, **kwargs)
        else:
            (data) = self.replace_process_group_with_http_info(body, id, **kwargs)
            return data

    def replace_process_group_with_http_info(self, body, id, **kwargs):
        """
        Replace Process Group contents with the given ID with the specified Process Group contents
        This endpoint is used for replication within a cluster, when replacing a flow with a new flow. It expects that the flow beingreplaced is not under version control and that the given snapshot will not modify any Processor that is currently running or any Controller Service that is enabled. Note: This endpoint is subject to change as NiFi and it's REST API evolve.
        This method makes a synchronous HTTP request.
        :param ProcessGroupImportEntity body: The process group replace request entity. (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupImportEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `replace_process_group`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replace_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/flow-contents', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupImportEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_process_group(self, body, id, **kwargs):
        """
        Updates a process group
        This method makes a synchronous HTTP request.
        :param ProcessGroupEntity body: The process group configuration details. (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_process_group_with_http_info(body, id, **kwargs)
        else:
            (data) = self.update_process_group_with_http_info(body, id, **kwargs)
            return data

    def update_process_group_with_http_info(self, body, id, **kwargs):
        """
        Updates a process group
        This method makes a synchronous HTTP request.
        :param ProcessGroupEntity body: The process group configuration details. (required)
        :param str id: The process group id. (required)
        :return: ProcessGroupEntity
        """

        all_params = ['body', 'id']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_process_group`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_process_group`")

 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload_process_group(self, id, **kwargs):
        """
        Uploads a versioned flow definition and creates a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str client_id:
        :param bool disconnected_node_acknowledged:
        :param object file:
        :param str group_name:
        :param float position_x:
        :param float position_y:
        :return: ProcessGroupEntity
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_process_group_with_http_info(id, **kwargs)
        else:
            (data) = self.upload_process_group_with_http_info(id, **kwargs)
            return data

    def upload_process_group_with_http_info(self, id, **kwargs):
        """
        Uploads a versioned flow definition and creates a process group
        This method makes a synchronous HTTP request.
        :param str id: The process group id. (required)
        :param str client_id:
        :param bool disconnected_node_acknowledged:
        :param object file:
        :param str group_name:
        :param float position_x:
        :param float position_y:
        :return: ProcessGroupEntity
        """

        all_params = ['id', 'client_id', 'disconnected_node_acknowledged', 'file', 'group_name', 'position_x', 'position_y']
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `upload_process_group`")

 
 
 
 
 
 
 
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'client_id' in params:
            form_params.append(('clientId', params['client_id']))
        if 'disconnected_node_acknowledged' in params:
            form_params.append(('disconnectedNodeAcknowledged', params['disconnected_node_acknowledged']))
        if 'file' in params:
            form_params.append(('file', params['file']))
        if 'group_name' in params:
            form_params.append(('groupName', params['group_name']))
        if 'position_x' in params:
            form_params.append(('positionX', params['position_x']))
        if 'position_y' in params:
            form_params.append(('positionY', params['position_y']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['bearerAuth']

        return self.api_client.call_api('/process-groups/{id}/process-groups/upload', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProcessGroupEntity',
                                        auth_settings=auth_settings,
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
