import logging
import ssl
from typing import Dict, List, Optional, Any, Union, Tuple, TypeVar, Generic
from urllib.parse import urlencode

import httpx
from {{packageName}}.rest import RESTClientObject
from {{packageName}}.configuration import Configuration
from {{packageName}}.exceptions import ApiException, ApiValueError

logger = logging.getLogger(__name__)
T = TypeVar('T')

class ApiClient(Generic[T]):
    """Generic API client for making HTTP requests"""

    def __init__(
        self,
        configuration: Optional[Configuration] = None,
        header_name: Optional[str] = None,
        header_value: Optional[str] = None,
        cookie: Optional[str] = None,
        pool_threads: int = 1,
        timeout: Optional[float] = None,
        verify_ssl: bool = True,
        ssl_context: Optional[ssl.SSLContext] = None,
        proxy: Optional[str] = None,
    ):
        """Initialize the API client

        Args:
            configuration: Configuration object
            header_name: Custom header name
            header_value: Custom header value
            cookie: Cookie value
            pool_threads: Number of threads in the connection pool
            timeout: Request timeout in seconds
            verify_ssl: Whether to verify SSL certificates
            ssl_context: SSL context for HTTPS connections
            proxy: Proxy URL if needed
        """
        self.configuration = configuration or Configuration()
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        self.pool_threads = pool_threads
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.ssl_context = ssl_context
        self.proxy = proxy

        # Initialize the REST client
        self.rest_client = RESTClientObject(
            configuration=self.configuration,
            pools_size=pool_threads,
            timeout=timeout,
            verify_ssl=verify_ssl,
            ssl_context=ssl_context,
            proxy=proxy,
        )

    async def __aenter__(self) -> 'ApiClient':
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

    async def close(self):
        """Close the underlying REST client"""
        await self.rest_client.close()

    async def call_api(
        self,
        resource_path: str,
        method: str,
        path_params: Optional[Dict[str, Any]] = None,
        query_params: Optional[List[Tuple[str, str]]] = None,
        header_params: Optional[Dict[str, str]] = None,
        body: Optional[Any] = None,
        post_params: Optional[List[Tuple[str, Any]]] = None,
        files: Optional[Dict[str, Any]] = None,
        response_type: Optional[str] = None,
        auth_settings: Optional[List[str]] = None,
        _return_http_data_only: bool = False,
        _preload_content: bool = True,
        _request_timeout: Optional[Union[int, float, Tuple[int, int]]] = None,
    ) -> Tuple[Any, int, Dict[str, str]]:
        """Make an API call

        Args:
            resource_path: Path to the resource
            method: HTTP method
            path_params: Path parameters
            query_params: Query parameters
            header_params: Header parameters
            body: Request body
            post_params: POST parameters
            files: Files to upload
            response_type: Expected response type
            auth_settings: Authentication settings
            _return_http_data_only: Whether to return only the response data
            _preload_content: Whether to preload the response content
            _request_timeout: Request timeout

        Returns:
            Tuple of (response data, status code, headers)

        Raises:
            ApiException: If the API call fails
        """
        # Build the URL
        url = self.configuration.host + resource_path
        if path_params:
            url = url.format(**path_params)

        # Build headers
        headers = self.default_headers.copy()
        if header_params:
            headers.update(header_params)

        # Make the request
        try:
            return await self.rest_client.request(
                method=method,
                url=url,
                headers=headers,
                query_params=query_params,
                body=body,
                post_params=post_params,
                files=files,
                response_type=response_type,
                auth_settings=auth_settings,
                _return_http_data_only=_return_http_data_only,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
            )
        except ApiException as e:
            logger.error(f"API call failed: {e}")
            raise

    def select_header_accept(self, accepts: List[str]) -> str:
        """Select the Accept header value

        Args:
            accepts: List of acceptable MIME types

        Returns:
            Selected MIME type
        """
        if not accepts:
            return 'application/json'
        return accepts[0]

    def select_header_content_type(self, content_types: List[str]) -> str:
        """Select the Content-Type header value

        Args:
            content_types: List of content types

        Returns:
            Selected content type
        """
        if not content_types:
            return 'application/json'
        return content_types[0]

    def update_params_for_auth(
        self,
        headers: Dict[str, str],
        querys: List[Tuple[str, str]],
        auth_settings: Optional[List[str]] = None,
    ) -> None:
        """Update parameters for authentication

        Args:
            headers: Headers to update
            querys: Query parameters to update
            auth_settings: Authentication settings
        """
        if not auth_settings:
            return

        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting:
                if auth_setting['in'] == 'header':
                    headers[auth_setting['key']] = auth_setting['value']
                elif auth_setting['in'] == 'query':
                    querys.append((auth_setting['key'], auth_setting['value'])) 